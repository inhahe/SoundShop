   /* template<typename T, typename... Args>
    void write3(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      T value, Args... args)
    {
      write2(pipe, value);         // Write current value
      write3(pipe, args...);       // Recursively write remaining values
    }

    // Variadic template for writing multiple values
    template<typename T>
    void write3(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      T value)
    {
      write2(pipe, value);  // Base case: write single value
    }

    */

/*    template<typename T, typename... Args>
    void write3(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      T value, Args... args)
    {
      write2(pipe, value);
      if constexpr (sizeof...(args) > 0) {  // C++17
        write3(pipe, args...);
      }
    }

    */

  /*  template<typename T>
    void write3_impl(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      T value)
    {
      write2(pipe, value);
    }

    // Recursive case - has additional parameters (private helper)
    template<typename T, typename... Args>
    void write3_impl(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      T value, Args... args)
    {
      write2(pipe, value);
      write3_impl(pipe, args...);  // Note: calls write3_impl, not write3
    }

    // Public interface - this is what you call
    template<typename... Args>
    void write3(
#ifdef _WIN32
      HANDLE pipe,
#else
      int pipe,
#endif
      Args... args)
    {
      write3_impl(pipe, args...);
    }

    */

----

class CompletePluginHost : public juce::Timer, public juce::MidiInputCallback
{
public:
    CompletePluginHost(const std::string& pipeName) : pipeName(pipeName)
    {
        // Create the pipe ONCE during initialization
#ifdef _WIN32
        std::string fullPipeName = "\\\\.\\pipe\\" + pipeName;
        currentPipe = CreateNamedPipeA(
            fullPipeName.c_str(),
            PIPE_ACCESS_DUPLEX,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            1, 1024, 1024, 0, NULL);
            
        if (currentPipe == INVALID_HANDLE_VALUE) {
            throw std::runtime_error("Failed to create named pipe: " + std::to_string(GetLastError()));
        }
        
        std::cout << "Named pipe created: " << fullPipeName << std::endl;
#else
        // Linux: create FIFO once
        if (mkfifo(pipeName.c_str(), 0666) == -1 && errno != EEXIST) {
            throw std::runtime_error("Failed to create FIFO");
        }
#endif
    }
    
    ~CompletePluginHost() {
        // Clean up pipe
#ifdef _WIN32
        if (currentPipe != INVALID_HANDLE_VALUE) {
            CloseHandle(currentPipe);
        }
#else
        if (currentPipe != -1) {
            close(currentPipe);
            unlink(pipeName.c_str()); // Remove FIFO file
        }
#endif
    }

private:
    std::string pipeName;
#ifdef _WIN32
    HANDLE currentPipe = INVALID_HANDLE_VALUE;
#else
    int currentPipe = -1;
#endif
Then ProcessCommands() just reads from the existing pipe:
cppvoid ProcessCommands() {
    // Just read from the already-created pipe
    // No CreateNamedPipe here!
}

---

class ParameterChangeListener : public juce::AudioProcessorListener
{
public:
    void audioProcessorParameterChanged(juce::AudioProcessor* processor, 
                                       int parameterIndex, 
                                       float newValue) override
    {
        std::cout << "Parameter " << parameterIndex 
                  << " changed to " << newValue 
                  << " on processor " << processor << std::endl;
                  
        // You can send this change back to Python client
        notifyPythonOfParameterChange(processor, parameterIndex, newValue);
    }
    
    void audioProcessorChanged(juce::AudioProcessor* processor, 
                              const juce::AudioProcessorListener::ChangeDetails& details) override
    {
        // Called for other changes (program changes, etc.)
    }
};

// Attach listener to your plugins:
ParameterChangeListener paramListener;

void addPlugin(juce::AudioProcessor* plugin) {
    plugin->addListener(&paramListener);
    // ... rest of plugin setup
}

---

class ParameterChangeListener : public juce::AudioProcessorListener
{
private:
  bool suppressNotifications = false;

public:
  void setSuppressNotifications(bool suppress) { suppressNotifications = suppress; }

  void audioProcessorParameterChanged(juce::AudioProcessor* processor,
    int parameterIndex,
    float newValue) override
  {
    if (!suppressNotifications) {
      // Only notify Python of user-initiated changes
      notifyPythonOfParameterChange(processor, parameterIndex, newValue);
    }
  }
};

// In your scheduler:
void setPluginParameter(int pluginId, int paramIndex, float value) {
  paramListener.setSuppressNotifications(true);

  // Make the scheduled parameter change
  auto* plugin = getPluginById(pluginId);
  plugin->getParameters()[paramIndex]->setValue(value);

  paramListener.setSuppressNotifications(false);
}

---

    Response loadPluginByIndex(const std::string& indexStr, const std::string& id)
    {
        try
        {
            int index = std::stoi(indexStr);
            if (index >= 0 && index < availablePlugins.size())
            {
                const auto* desc = availablePlugins[index];
                return loadPlugin(desc->fileOrIdentifier.toStdString(), id);
            }
            else
            {
                Response resp;
                resp.success = false;
                resp.message = "Invalid plugin index";
                return resp;
            }
        }
        catch (...)
        {
            Response resp;
            resp.success = false;
            resp.message = "Invalid index format";
            return resp;
        }
    }

---


    struct listAvailablePluginsR {int size;};
    void scanPluginDirectories(std::vector<std::string> directories)
    {
        // First, let's see what files are actually in the directory
        for (const auto& strdirectory : directories)
        {
          auto directory = juce::File(strdirectory);
          juce::Array<juce::File> allFiles = directory.findChildFiles(juce::File::findFiles, false);
        
          // Look for plugin files by extension
          juce::Array<juce::File> potentialPlugins;
        
          for (const auto& file : allFiles)
          {
              juce::String extension = file.getFileExtension().toLowerCase();
              std::cout << "Checking file: " << file.getFileName() << " (ext: " << extension << ")" << std::endl;
            
              if (extension == ".dll" || extension == ".vst" || extension == ".vst3")
              {
                  potentialPlugins.add(file);
              }
          }
        
          // Also check for .vst3 directories
          juce::Array<juce::File> vst3Dirs = directory.findChildFiles(juce::File::findDirectories, false, "*.vst3");
          potentialPlugins.addArray(vst3Dirs);
        
//          std::cout << "Found " << potentialPlugins.size() << " potential plugin files/directories" << std::endl;
        
          // Try to load each potential plugin
          for (const auto& pluginFile : potentialPlugins)
          {
  //            std::cout << "Attempting to scan: " << pluginFile.getFullPathName() << std::endl;
            
              bool foundPlugin = false;
            
              for (auto* format : formatManager.getFormats())
              {
       //           std::cout << "  Trying format: " << format->getName() << std::endl;
                
                  if (format->fileMightContainThisPluginType(pluginFile.getFullPathName()))
                  {
    //                  std::cout << "    Format thinks it might contain plugins" << std::endl;
                    
                      juce::OwnedArray<juce::PluginDescription> descriptions;
                      format->findAllTypesForFile(descriptions, pluginFile.getFullPathName());
                    
      //                std::cout << "    Found " << descriptions.size() << " plugin descriptions" << std::endl;
                    
                      for (auto* desc : descriptions)
                      {
        //                  std::cout << "      Plugin: " << desc->name << " by " << desc->manufacturerName << std::endl;
                        
                          // Check for duplicates
                          bool alreadyExists = false;
                          for (auto* existing : availablePlugins)
                          {
                            if (existing->fileOrIdentifier == desc->fileOrIdentifier &&
                              existing->name == desc->name)
                            {
                              alreadyExists = true;
                              break;
                            }
                          }
                        
                          if (!alreadyExists)
                          {
                              availablePlugins.add(new juce::PluginDescription(*desc));
                              foundPlugin = true;
//                              std::cout << "        -> Added to available plugins list" << std::endl;
                          }
        //                  else
          //                {
 //                             std::cout << "        -> Already in list, skipping" << std::endl;
            //              }
                      }
                  }
//                  else
  //                {
   //                   std::cout << "    Format doesn't think it contains plugins" << std::endl;
    //              }
      //        }
            
//              if (!foundPlugin)
//              {
     //             std::cout << "  No valid plugins found in " << pluginFile.getFileName() << std::endl;
//              }
          }
        
          //std::cout << "Directory scan complete. Total plugins in list: " << availablePlugins.size() << std::endl;
      }

---

int scanForPlugins(const std::string& directory)
    {
        if (directory.empty())
        {
            scanDefaultPluginDirectories();
        }
        else
        {
            juce::File pluginDir(directory);
            if (pluginDir.exists() && pluginDir.isDirectory())
            {
                scanPluginDirectory(pluginDir);
            }
            else
            {
                resp.success = false;
                resp.message = "Directory not found: " + directory;
                return resp;
            }
        }
        
        resp.success = true;
        resp.message = "Scan completed";
        resp.data["plugins_found"] = std::to_string(availablePlugins.size());
        return resp;
    }
---
bool loadPluginByIndex(int index)
    {
      if (index >= 0 && index < availablePlugins.size()) {
        const availablePlugin& pluginInfo = availablePlugins[index];  // Use reference

        juce::String errorMessage;  // Declare the error message variable

        // createPluginInstance returns a unique_ptr, don't wrap it again
        auto plugin = formatManager.createPluginInstance(
          pluginInfo.desc, sampleRate, blockSize, errorMessage);

        if (plugin != nullptr) {
          // Register the listener BEFORE moving the plugin
          plugin->addListener(&paramListener);

          // Move the plugin into the graph (processorGraph, not audioGraph)
          auto nodeId = processorGraph->addNode(std::move(plugin));

          if (nodeId != nullptr) {
            // Store the mapping if you need it
            loadedPlugins[std::to_string(index)] = nodeId->nodeID;
            return true;
          }
        }
        else {
          std::cout << "Failed to load plugin: " << errorMessage.toStdString() << std::endl;
        }
      }
      return false;
    }
---

/*
#define WRITE_ALL(...) do { \
    auto dummy = {(write2(__VA_ARGS__), 0)...}; \
    (void)dummy; \
} while(0)
*/

/*
#define WRITE_ALL(...) do { \
    int dummy[] = { 0, (write2(__VA_ARGS__), 0)... }; \
    (void)dummy; \
} while(0)
*/

//#define WRITE_ALL(...) ((write2(__VA_ARGS__)), ...)

---

 struct availablePluginR
    {
      uint32_t isinstrument;
      uint32_t uniqueid;
      string name;
      string descriptivename;
      string pluginformatname;
      string category;
      string mfgname;
      string version;
      string id;
      string timechanged;
      string path;
    };

---

    getPluginInfo(int index)
    {
        Response resp;
        
        try
        {
            if (index >= 0 && index < availablePlugins.size())
            {
                const auto* desc = availablePlugins[index];
                resp.success = true;
                resp.message = "Plugin info";
                resp.data["name"] = desc->name.toStdString();
                resp.data["manufacturer"] = desc->manufacturerName.toStdString();
                resp.data["path"] = desc->fileOrIdentifier.toStdString();
                resp.data["version"] = desc->version.toStdString();
                resp.data["format"] = desc->pluginFormatName.toStdString();
                resp.data["inputs"] = to_string(desc->numInputChannels);
                resp.data["outputs"] = to_string(desc->numOutputChannels);
                resp.data["is_synth"] = desc->isInstrument ? "true" : "false";
            }
            else
            {
                resp.success = false;
                resp.message = "Invalid plugin index";
            }
        }
        catch (...)
        {
            resp.success = false;
            resp.message = "Invalid index format";
        }
        
        return resp;
    }

---


struct RecordedParameterChange {
  int pluginId;
  int parameterIndex;
  float value;
  uint64_t blockNumber;
  chrono::steady_clock::time_point timestamp; // Optional: real-world time too
};

class ParameterRecorder {
private:
  vector<RecordedParameterChange> recordedChanges;

public:
  void startRecording() {
    recordedChanges.clear();
    recordedChanges.reserve(1000000);  
    isRecording = true;
  }

  void recordParameterChange(int pluginId, int paramIndex, float value) {
    if (isRecording && !suppressNotifications) {
      // Check if we're getting close to capacity
      if (recordedChanges.size() >= recordedChanges.capacity() - 100) {
        recordedChanges.reserve(recordedChanges.capacity() * 2);  // Double it
        cout << "Expanded parameter buffer to " << recordedChanges.capacity() << endl;
      }

      recordedChanges.emplace_back(pluginId, paramIndex, value, app.scheduler.getCurrentBlock(), chrono::steady_clock::now());
    }
  }
};

---
    void scanPluginDirectories(std::vector<std::string> directories)
    {
        // First, let's see what files are actually in the directory
        for (const auto& strdirectory : directories)
        {
            auto directory = juce::File(strdirectory);
            juce::Array<juce::File> allFiles = directory.findChildFiles(juce::File::findFiles, false);
        
            // Look for plugin files by extension
            juce::Array<juce::File> potentialPlugins;
        
            for (const auto& file : allFiles)
            {
                juce::String extension = file.getFileExtension().toLowerCase();
                std::cout << "Checking file: " << file.getFileName() << " (ext: " << extension << ")" << std::endl;
            
                if (extension == ".dll" || extension == ".vst" || extension == ".vst3")
                {
                    potentialPlugins.add(file);
                }
            }
        
            // Also check for .vst3 directories
            juce::Array<juce::File> vst3Dirs = directory.findChildFiles(juce::File::findDirectories, false, "*.vst3");
            potentialPlugins.addArray(vst3Dirs);
            // Try to load each potential plugin
            for (const auto& pluginFile : potentialPlugins)
            {
                bool foundPlugin = false;
                for (auto* format : formatManager.getFormats())
                {
                  if (format->fileMightContainThisPluginType(pluginFile.getFullPathName()))
                  {
                    juce::OwnedArray<juce::PluginDescription> descriptions;
                    format->findAllTypesForFile(descriptions, pluginFile.getFullPathName());
                    for (auto* desc : descriptions)
                    {
                      // Check for duplicates
                      bool alreadyExists = false;
                      for (auto* existing : availablePlugins)
                      {
                        if (existing->fileOrIdentifier == desc->fileOrIdentifier &&
                          existing->name == desc->name)
                        {
                          alreadyExists = true;
                          break;
                        }
                      }

                      if (!alreadyExists)
                      {
                        availablePlugins.add(new juce::PluginDescription(*desc));
                      }
                    }
                  }
                }
            }
      }

---
void waitForConnection() 
  {
#ifdef _WIN32
    ConnectNamedPipe(hPipe, NULL);
#endif
    startCommandProcessing();
  }

---
  template<>
  string readFromPipe<string>() {
    // Read 4-byte length first
    uint32_t length = readFromPipe<uint32_t>();
    if (length <= 0 || length > 10000) 
    {  // Sanity check
      throw runtime_error("invalid string length");
    }
    char* buffer = new char[length];
    int totalRead = 0;
    while (totalRead < length) {
      DWORD bytesRead;
      if (!ReadFile(hPipe, buffer + totalRead, length - totalRead, &bytesRead, NULL)) {
        delete [] buffer;
        throw runtime_error("ReadFile failed: " + to_string(GetLastError()));
      }
      if (bytesRead == 0)
      {
        delete [] buffer;
        throw runtime_error("pipe closed");
      }
      totalRead += bytesRead;
    }

    // Read string content
    buffer[length] = '\0';
    string result(buffer, length);
    delete[] buffer;
    return result;
  }

---
  struct loadPluginR {uint32_t success = false; string errmsg = ""; string name = ""; string uid = ""; };
  loadPluginR loadPlugin(const string& path, const int id)
  {
    loadPluginR resp;
    juce::MessageManager::callAsync([this, path, id, &resp]() {
      // Load the plugin
      juce::OwnedArray<juce::PluginDescription> descriptions;

      for (auto* format : formatManager.getFormats())
      {
        if (format->fileMightContainThisPluginType(path))
        {
          format->findAllTypesForFile(descriptions, path);
          break;
        }
      }

      if (descriptions.size() > 0)
      {
        const juce::PluginDescription& desc = *descriptions[0];
        juce::String errorMessage;
        auto* instance = formatManager.createPluginInstance(
          desc,
          processorGraph->getSampleRate(),
          processorGraph->getBlockSize(),
          errorMessage
        ).release();

        if (instance)
        {
          auto nodeId = processorGraph->addNode(
            unique_ptr<juce::AudioProcessor>(instance)
          )->nodeID;

          loadedPlugins[id] = nodeId;

          resp.success = true;
          resp.name = desc.name.toStdString();
          resp.uid = to_string(nodeId.uid);
        }
        else
        {
          resp.success = false;
          resp.errmsg = errorMessage.toStdString();
        }
      }
      else
      {
        resp.success = false;
        resp.errmsg = "Plugin not found at path: " + path;
      }
      });

    return resp;
  }


---
  loadPluginR loadPlugin(const string& path, const int id)
  {
    loadPluginR resp;
    juce::OwnedArray<juce::PluginDescription> descriptions;

    for (auto* format : formatManager.getFormats())
    {
      if (format->fileMightContainThisPluginType(path))
      {
        format->findAllTypesForFile(descriptions, path);
        break;
      }
    }

    if (descriptions.size() > 0)
    {
      const juce::PluginDescription& desc = *descriptions[0];
      juce::String errorMessage;
      auto* instance = formatManager.createPluginInstance(
        desc,
        processorGraph->getSampleRate(),
        processorGraph->getBlockSize(),
        errorMessage
      ).release();

      if (instance)
      {
        auto nodeId = processorGraph->addNode(
          unique_ptr<juce::AudioProcessor>(instance)
        )->nodeID;

        loadedPlugins[id] = nodeId;

        resp.success = true;
        resp.name = desc.name.toStdString();
        resp.uid = to_string(nodeId.uid);
      }
      else
      {
        resp.success = false;
        resp.errmsg = errorMessage.toStdString();
      }
    }
    else
    {
      resp.success = false;
      resp.errmsg = "Plugin not found at path: " + path;
    }
    return resp;
  }

---
loadPluginR loadPlugin(const string& path, const int id)
  {
    loadPluginR resp;
    auto loadFunc = [this, path, id, &resp]() 
    {
      juce::OwnedArray<juce::PluginDescription> descriptions;
      for (auto* format : formatManager.getFormats())
      {
        if (format->fileMightContainThisPluginType(path))
        {
          format->findAllTypesForFile(descriptions, path);
          break;
        }
      }

      if (descriptions.size() > 0)
      {
        const juce::PluginDescription& desc = *descriptions[0];
        juce::String errorMessage;
        auto* instance = formatManager.createPluginInstance(
          desc,
          processorGraph->getSampleRate(),
          processorGraph->getBlockSize(),
          errorMessage
        ).release();

        if (instance)
        {
          auto nodeId = processorGraph->addNode(
            unique_ptr<juce::AudioProcessor>(instance)
          )->nodeID;

          loadedPlugins[id] = nodeId;

          resp.success = true;
          resp.name = desc.name.toStdString();
          resp.uid = to_string(nodeId.uid);
        }
        else
        {
          resp.success = false;
          resp.errmsg = errorMessage.toStdString();
        }
      }
      else
      {
        resp.success = false;
        resp.errmsg = "Plugin not found at path: " + path;
      }
    };
    if (juce::MessageManager::getInstance()->isThisTheMessageThread()) 
    {
      loadFunc();
    } 
    else 
    {
      juce::MessageManager::callBlockingFromAnyThread(loadFunc);
    }

    return resp;
  }

  ---
    int scanPluginDirectory(const juce::File& directory)
  {
    cout << "scanning plugin directory recursively: " << directory.getFullPathName() << endl;
    juce::Array<juce::File> pluginFiles;

#ifdef _WIN32
    // Windows: scan for DLLs and VST3 bundles
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.dll"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.vst3"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.vst"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.vst3"));

#elif defined(__APPLE__)
    // macOS: scan for bundles and dylibs
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.vst"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.vst3"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.component")); // AU
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.dylib"));

#elif defined(__linux__)
    // Linux: scan for shared objects and plugin bundles
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.so"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.vst3"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findFiles, true, "*.vst"));
    pluginFiles.addArray(directory.findChildFiles(juce::File::findDirectories, true, "*.lv2")); // LV2 bundles
#endif
    for (const auto& pluginFile : pluginFiles)
    {
      for (auto* format : formatManager.getFormats())
      {
        if (format->fileMightContainThisPluginType(pluginFile.getFullPathName()))
        {
          juce::OwnedArray<juce::PluginDescription> descriptions;
          format->findAllTypesForFile(descriptions, pluginFile.getFullPathName());
          for (auto* desc : descriptions)
          {
            // Check for duplicates
            bool alreadyExists = false;
            for (const availablePlugin& existing : availablePlugins)
            {
              if (existing.desc.fileOrIdentifier == desc->fileOrIdentifier && existing.desc.name == desc->name)
              {
                alreadyExists = true;
                break;
              }
            }
            if (!alreadyExists)
            {
              availablePlugin plugin;
              plugin.desc = *desc;     // Copy the description (not pointer)
              plugin.path = pluginFile.getFullPathName().toStdString();
              availablePlugins.push_back(plugin);
            }
          }
          break; // Found compatible format
        }
      }
    }
    return availablePlugins.size();
  }
---
void setPluginParameter(int pluginId, int parameterIndex, float value) {
    auto it = loadedPlugins.begin();
    advance(it, pluginId);  // Move iterator to pluginId position
    if (it != loadedPlugins.end()) {
      auto node = processorGraph->getNodeForId(it->second);
      if (node && node->getProcessor()) {
        auto* processor = node->getProcessor();
        if (parameterIndex >= 0 && parameterIndex < processor->getParameters().size()) {
          suppressNotifications = true;  // Prevent recording our own changes
          processor->getParameters()[parameterIndex]->setValue(value);
          suppressNotifications = false;
        }
      }
    }
  }
---
          if (auto* floatParam = dynamic_cast<juce::AudioParameterFloat*>(param))
          {
            paramR.min = floatParam->range.start;
            paramR.max = floatParam->range.end;
          }

---
void BlockLevelScheduler::processScheduledChanges() 
{
  for (auto& change : scheduledChanges) 
  {
    if (!change.executed && currentBlock >= change.atBlock) 
    {
      // Execute the parameter change RIGHT BEFORE this block processes
      app->setPluginParameter(change.pluginId, change.parameterIndex, change.value);
      change.executed = true;

      cout << "Executed parameter change at block " << currentBlock //debug
        << ": plugin " << change.pluginId
        << ", param " << change.parameterIndex
        << " = " << change.value << endl;
    }
  }
}

---


class MidiScheduler 
{
    // ... previous private members ...
    std::mutex schedulerMutex;  // Still need this for thread safety when scheduling
    
public:
    // ... previous methods ...
    
    // Thread-safe scheduling (called from command thread)
    void scheduleNote(int pluginId, int noteNumber, float velocity, 
                     double startTimeSeconds, double durationSeconds, int channel = 1) 
    {
        int64_t startSample = currentSamplePosition + 
                             static_cast<int64_t>(startTimeSeconds * sampleRate);
        int64_t endSample = startSample + 
                            static_cast<int64_t>(durationSeconds * sampleRate);
        
        std::lock_guard<std::mutex> lock(schedulerMutex);
        
        // Add events
        scheduledEvents.push_back({
            juce::MidiMessage::noteOn(channel, noteNumber, velocity),
            startSample, pluginId
        });
        scheduledEvents.push_back({
            juce::MidiMessage::noteOff(channel, noteNumber),
            endSample, pluginId
        });
        
        // Only sort the new portion
        std::sort(scheduledEvents.begin() + nextEventIndex, scheduledEvents.end(),
            [](const auto& a, const auto& b) { 
                return a.samplePosition < b.samplePosition; 
            });
    }
    
    // Schedule raw MIDI messages
    void scheduleMidiMessage(int pluginId, const juce::MidiMessage& msg, 
                            double timeSeconds) 
    {
        int64_t sample = currentSamplePosition + 
                        static_cast<int64_t>(timeSeconds * sampleRate);
        
        std::lock_guard<std::mutex> lock(schedulerMutex);
        scheduledEvents.push_back({msg, sample, pluginId});
        
        std::sort(scheduledEvents.begin() + nextEventIndex, scheduledEvents.end(),
            [](const auto& a, const auto& b) { 
                return a.samplePosition < b.samplePosition; 
            });
    }
    
    // Schedule CC messages
    void scheduleCC(int pluginId, int controller, int value, 
                   double timeSeconds, int channel = 1) 
    {
        auto msg = juce::MidiMessage::controllerEvent(channel, controller, value);
        scheduleMidiMessage(pluginId, msg, timeSeconds);
    }
    
    // Schedule pitch bend
    void schedulePitchBend(int pluginId, int value, double timeSeconds, int channel = 1) 
    {
        auto msg = juce::MidiMessage::pitchWheel(channel, value);
        scheduleMidiMessage(pluginId, msg, timeSeconds);
    }
    
    // Clear all scheduled events
    void clearSchedule() 
    {
        std::lock_guard<std::mutex> lock(schedulerMutex);
        scheduledEvents.clear();
        nextEventIndex = 0;
    }
    
    // Reset playback position (e.g., when stopping/starting)
    void reset() 
    {
        std::lock_guard<std::mutex> lock(schedulerMutex);
        currentSamplePosition = 0;
        nextEventIndex = 0;
    }
    
    // Get events for a specific plugin (if routing per-plugin)
    void getEventsForPlugin(int pluginId, juce::MidiBuffer& buffer, int blockSize) 
    {
        buffer.clear();
        int64_t blockEnd = currentSamplePosition + blockSize;
        
        size_t index = nextEventIndex;
        while (index < scheduledEvents.size()) 
        {
            const auto& event = scheduledEvents[index];
            if (event.samplePosition >= blockEnd) break;
            
            if (event.targetPluginId == pluginId && 
                event.samplePosition >= currentSamplePosition) 
            {
                int offset = static_cast<int>(event.samplePosition - currentSamplePosition);
                buffer.addEvent(event.message, offset);
            }
            index++;
        }
    }
    
    // Update sample rate if it changes
    void setSampleRate(double sr) 
    {
        std::lock_guard<std::mutex> lock(schedulerMutex);
        sampleRate = sr;
    }
    
    // Get scheduling status
    size_t getNumPendingEvents() const 
    {
        return scheduledEvents.size() - nextEventIndex;
    }
    
    int64_t getCurrentPosition() const { return currentSamplePosition; }
};

---

  getChannnelsInfoR getChannelsInfo(int lpindex) 
  {
    getChannnelsInfoR resp;
    vector<busR> buses;

    auto it = loadedPlugins.find(lpindex);
    if (it != loadedPlugins.end()) {
      auto node = processorGraph->getNodeForId(it->second);
      if (node && node->getProcessor()) {
      
        cout << "node->getProcessor()" << endl;
        auto* processor = node->getProcessor();
        cout << "processor pointer = " << processor << endl;

        // Basic channel counts

        // MIDI capabilities
        cout << "processor->acceptsMidi()" << endl;
        resp.acceptsMidi = processor->acceptsMidi();
        cout << "processor->producesMidi()" << endl;
        resp.producesMidi = processor->producesMidi();
        cout << "processor->getBusesLayout()" << endl;
        // Bus layout info
        auto layout = processor->getBusesLayout();

        // For each input/output bus:
        vector<busR> inputChannels;
        for (int i = 0; i < processor->getBusCount(true); ++i) 
        {
          busR bus2;
          vector<string> channelTypes;

          cout << "processor->getBus(true, i) " << i << endl;

          auto* bus = processor->getBus(true, i);  // true = input
          int numChannels = bus->getNumberOfChannels();
          string busName = bus->getName().toStdString();
          bool isEnabled = bus->isEnabled();
          auto& inputBus = processor->getBus(true, i)->getCurrentLayout();
          for (int chan = 0; chan < numChannels; chan++)
          {
            auto channelType = inputBus.getTypeOfChannel(chan);
            string channelName = juce::AudioChannelSet::getChannelTypeName(channelType).toStdString();
            channelTypes.push_back(channelName);
          }
          bus2.channelTypes = channelTypes;
          bus2.numChannels = numChannels;
          bus2.isEnabled = isEnabled;
          bus2.mainBusLayout = inputBus.getDescription().toStdString();
          resp.inputBuses.push_back(bus2);
        }

        for (int i = 0; i < processor->getBusCount(false); ++i) 
        {
          busR bus2;
          vector<string> channelTypes;

          cout << "processor->getBus(false, i) " << i << endl;

          auto* bus = processor->getBus(false, i); 
          int numChannels = bus->getNumberOfChannels();
          string busName = bus->getName().toStdString();
          bool isEnabled = bus->isEnabled();
          auto& inputBus = processor->getBus(false, 0)->getCurrentLayout();
          for (int chan = 0; chan < numChannels; chan++)
          {
            auto channelType = inputBus.getTypeOfChannel(chan);
            string channelName = juce::AudioChannelSet::getChannelTypeName(channelType).toStdString();
            channelTypes.push_back(channelName);
          }
          bus2.channelTypes = channelTypes;
          bus2.numChannels = numChannels;
          bus2.isEnabled = isEnabled;
          bus2.mainBusLayout = inputBus.getDescription().toStdString();
          resp.outputBuses.push_back(bus2);
        }
        resp.success = true;
      }
    } 
    else 
    {
      resp.errmsg = "Plugin not loaded";
    }
    return resp;
  }

---

void BlockLevelScheduler::processScheduledChanges() 
{
  ScheduledParameterChange change;
  while (currentBlock == ((change = scheduledChanges[lastChangeIndex]).atBlock))
  {
    lastChangeIndex++;
    app->setPluginParameter(change.lpindex, change.parameterIndex, change.value);
    change.executed = true;
    cout << "Executed parameter change at block " << currentBlock //debug
      << ": plugin " << change.lpindex
      << ", param " << change.parameterIndex
      << " = " << change.value << endl;
  }
}

---

struct loadPluginByIndexR {uint32_t success = true; string name; uint32_t lpindex = -1; uint32_t uid = -1; string errmsg;};
loadPluginByIndexR loadPluginByIndex(int apindex) {  // Return the assigned plugin ID
  loadPluginByIndexR resp;
  if (apindex >= 0 && apindex < availablePlugins.size()) 
  {
    const availablePlugin& pluginInfo = availablePlugins[apindex];

    juce::String errorMessage;
    auto plugin = formatManager.createPluginInstance(
      pluginInfo.desc, sampleRate, blockSize, errorMessage);

    if (plugin != nullptr) 
    {
      if (realtime) plugin->addListener(&paramListener);
      juce::AudioProcessor* processorPtr = plugin.get();
      auto node = processorGraph->addNode(move(plugin));
      if (node != nullptr) {
        int lpindex = nextlpindex++;
        loadedPlugins[lpindex] = node->nodeID;
        processorTolpindex[processorPtr] = lpindex;
        resp.lpindex = lpindex;  // Return the ID Python should use
        resp.name = pluginInfo.desc.name.toStdString();
        resp.uid = node->nodeID.uid;
        resp.success = true;
        return resp;
      }
      else
      {
        resp.success = false;
        resp.errmsg = "Couldn't add node to processor graph";
      }
    }
    else
    {
      resp.errmsg = errorMessage.toStdString();
      resp.success = false;
      badPaths.insert(pluginInfo.path);
    }
  }
  else
  {
    resp.success = false;
    resp.errmsg = "Index out of range";
  }
  return resp;
}

void removePlugin(int lpindex) {
  auto it = loadedPlugins.find(lpindex);
  if (it != loadedPlugins.end()) {
    auto node = processorGraph->getNodeForId(it->second);
    if (node) {
      processorTolpindex.erase(node->getProcessor());
    }
    processorGraph->removeNode(it->second);
    loadedPlugins.erase(it);
  }
}


----
to route a plugin to audio:

  processorGraph->addConnection({
        {node->nodeID, 0},  // Plugin's left channel
        {audioOutputNode, 0}  // System left output
    });
    processorGraph->addConnection({
        {node->nodeID, 1},  // Plugin's right channel  
        {audioOutputNode, 1}  // System right output
    });

---
void initializeAudio()
{
  // Setup audio device
  auto setup = deviceManager.getAudioDeviceSetup();
  setup.sampleRate = 48000;
  setup.bufferSize = 512;

  if (!renderToFile) 
  {
    // Only initialize hardware if real-time mode
    juce::String error = deviceManager.initialise(
      2, 2, nullptr, true, {}, &setup);

    if (error.isNotEmpty()) {
      cerr << "Audio initialization error: " << error.toStdString() << endl;
    }
  }

  // Setup graph but DON'T start audio yet
  graphPlayer.setProcessor(processorGraph.get());
  // DON'T call deviceManager.addAudioCallback yet!
  
  // Initialize the MIDI scheduler
  midiScheduler = std::make_unique<MidiScheduler>(setup.sampleRate);

  // Setup graph player with the original processor graph
  graphPlayer.setProcessor(processorGraph.get());
  deviceManager.addAudioCallback(&graphPlayer);

  // Add this line:
  setupAudioIO();

  // Setup MIDI collector for hardware MIDI input
  midiCollector = make_unique<juce::MidiMessageCollector>();
  midiCollector->reset(setup.sampleRate);

  // Open MIDI inputs
  auto midiInputs = juce::MidiInput::getAvailableDevices();
  for (const auto& input : midiInputs)
  {
    deviceManager.setMidiInputDeviceEnabled(input.identifier, true);
    deviceManager.addMidiInputDeviceCallback(input.identifier, this);
  }
}

---

   void startPlayback(uint64_t lastBlock, bool toFile, const std::string& filename = "")
    {
        if (!audioInitialized) 
        {
            // Initialize audio system on first playback
            if (toFile) 
            {
                // No hardware needed for file rendering
                processorGraph->prepareToPlay(48000, 512);
                setupAudioIO();
                midiScheduler = std::make_unique<MidiScheduler>(48000);
            }
            else 
            {
                // Initialize hardware for real-time
                auto setup = deviceManager.getAudioDeviceSetup();
                setup.sampleRate = 48000;
                setup.bufferSize = 512;
                
                deviceManager.initialise(2, 2, nullptr, true, {}, &setup);
                
                graphPlayer.setProcessor(processorGraph.get());
                deviceManager.addAudioCallback(&graphPlayer);
                
                setupAudioIO();
                midiScheduler = std::make_unique<MidiScheduler>(setup.sampleRate);
                
                // Setup MIDI inputs
                auto midiInputs = juce::MidiInput::getAvailableDevices();
                for (const auto& input : midiInputs) {
                    deviceManager.setMidiInputDeviceEnabled(input.identifier, true);
                    deviceManager.addMidiInputDeviceCallback(input.identifier, this);
                }
            }
            audioInitialized = true;
        }
        
        // Now start actual playback
        if (toFile) {
            renderOfflineToFile(filename, lastBlock);
        } else {
            isPlaying = true;
            playbackEndBlock = lastBlock;
        }
    }
---
  struct getPluginInfoR 
  {
    uint32_t success;
    string errmsg;
    string descriptiveName;
    string pluginFormatName;
    string catgory;
    string manufacturerName;
    string version;
    string fileOrIdentifier;
    uint32_t isInstrument;
    uint32_t uniqueId;
    uint32_t numInputChannels;
    uint32_t numOutputChannels;
  };

  getPluginInfoR getPluginInfo(int apindex)
  {
    getPluginInfoR resp;
    const availablePlugin desc = availablePlugins[apindex];
    if (apindex >= 0 && apindex < availablePlugins.size())
    {
      const availablePlugin desc = availablePlugins[apindex].desc;
      resp.descriptiveName = desc.descriptiveName;

    }


  }

      case get_plugin_info:
      {
        uint32_t lpindex = READFROMPIPE(uint32_t);
        auto resp = getPluginInfo(apindex);
        WRITEALL(resp.success, resp.errmsg, resp.name, resp.manufacturerName, resp.path, resp.version, resp.pluginFormatName, resp.numInputChannels, 
          resp.numOutputChannels, resp.isInstrument, resp.uniqueID, resp.category);
        break;
      }


---
print(get_notes(get_semitones("A Bb C D E F G"), "F", "Ionian", True)) 
print(get_notes(get_semitones("Ab Bb Cb Db Eb Fb Gb"), "Câ™­")) 
print(get_notes(change_key(get_semitones("C D E F G A B"), "C", "Ionian", "C", "Dorian")))
notes = "A Bb C D E F G"
semis = get_semitones(notes)
keys = get_keys(semis)
print(f"{keys=}")
print(get_notes(semis, "F"))
print(get_notes(semis, keys[0][0]))
table = build_table("C#")
print(get_notes(table, notes_dict["C#"]))
---
for scale in scales:
  try:
    notes = musical_scales.scale("A", scale)
    notes2 = [note.midi for note in notes]
    print(f"{scale=}")
    print(f"{notes2=}")
    notes3 = notes_manipulation.get_semitones(notes2)
    print(f"{notes3=}")
    lastnote = None
    intervals = []
    for note in notes3:
      if lastnote is not None:
        intervals.append(note-lastnote)
      lastnote = note
    print(f"{intervals=}")
    d[scale] = intervals
  except musical_scales.MusicException as e:
    print(f"{scale=} {e=}")
#pprint.pprint(d)
print(d)
----


  for scale_name, scale in extra_scales.items():
    for key in range(len(scale)
    print(f"{scale_name=}")
    found_keys = []
    m_sc = min(scale)
    k_sc = m_sc%12
    scale_m = set(semi-m for semi in scale)
    for key in range(len(12):
      scale_mk = set(note+key for note in scale_m)
      if scale_mk.issubset(semis_m):
        found_keys.append(

    if semis_m.issubset(scale_m):
      found_scales.append((scale_name, k))
---
def get_notes(notes):
  if type(notes) is str:
    notes = notes.split()
  currentoctave = 4
  r = []
  for note in notes:
    if type(note) is str:
      if note.upper().startswith("O"):
        currentoctave = int(n[1:])
      else:
        note = Note(note)
      r.append(note)
  return r

// Write string with length prefix

class WriteBuffer {
public:
  std::vector<char> data;

  void append(const void* ptr, size_t size) {
    const char* bytes = static_cast<const char*>(ptr);
    data.insert(data.end(), bytes, bytes + size);
  }

  const char* getBuffer() const { return data.data(); }
  size_t getSize() const { return data.size(); }
};

WriteBuffer* currentWriteBuffer = nullptr;

int write2_string_with_buffer(const string& s)
{
  int l1 = static_cast<int>(s.length());
  int l2 = 4 + l1;
  int tosend = l2;
  int totalWritten = 0;

  char* buff = new char[l2];
  memcpy(buff, &l1, 4);
  memcpy(buff + 4, s.c_str(), l1);

  // Store in buffer if one is active
  if (currentWriteBuffer) {
    currentWriteBuffer->append(buff, l2);
  }

  char* current_pos = buff;
  while (tosend > 0) {
    int byteswritten = write4(current_pos, tosend);
    if (byteswritten > 0) {
      tosend -= byteswritten;
      current_pos += byteswritten;
      totalWritten += byteswritten;
    }
    else {
      delete[] buff;
      throw runtime_error("Error writing to pipe");
    }
  }
  delete[] buff;
  return totalWritten;
}

 template<typename T>
 int write2_binary_with_buffer(T n)
 {
   // Store in buffer if one is active
   if (currentWriteBuffer) {
     currentWriteBuffer->append(&n, sizeof(T));
   }

   int tosend = sizeof(T);
   int totalWritten = 0;
   char* current_pos = reinterpret_cast<char*>(&n);

   while (tosend > 0) {
     int byteswritten = write4(current_pos, tosend);
     if (byteswritten > 0) {
       tosend -= byteswritten;
       current_pos += byteswritten;
       totalWritten += byteswritten;
     }
     else {
       throw runtime_error("Error writing to pipe");
     }
   }
   return totalWritten;
 }

template<typename... Args>
WriteBuffer writeAllWithBuffer(Args&&... args) {
  WriteBuffer buffer;
  currentWriteBuffer = &buffer;

  // Call write2 for each argument
  ((write2(std::forward<Args>(args))), ...);

  currentWriteBuffer = nullptr;
  return buffer;
}


#define WRITEALL_BUFFER(...) writeAllWithBuffer(__VA_ARGS__) //debug. 


  //void processParameterNotifications()
  //{
  //  ParameterChangeEvent event;
  //  while (parameterQueue.pop(event)) 
  //  {
  //    // Send to Python via pipe (safe here - not in audio thread)
  //    cout << "param changed" << endl;
  //    WRITEALLN(param_changed, event.lpindex, event.parameterIndex, event.value);
  //  }
  //}

---
bool isPipeConnected() {
#ifdef _WIN32
    // Try to peek at the pipe without removing data
    DWORD bytesAvailable;
    DWORD bytesLeft;
    
    if (PeekNamedPipe(hCommandPipe, NULL, 0, NULL, &bytesAvailable, &bytesLeft)) {
        return true;  // Pipe is connected
    }
    
    DWORD error = GetLastError();
    if (error == ERROR_BROKEN_PIPE || error == ERROR_PIPE_NOT_CONNECTED) {
        return false;  // Pipe disconnected
    }
    
    return true;  // Other errors - assume still connected
#else
    // Linux implementation below
#endif
}
Linux (FIFOs):
cppbool isPipeConnected() {
#ifdef _WIN32
    // Windows code above
#else
    // Use poll() to check pipe status without blocking
    struct pollfd pfd;
    pfd.fd = commandPipe_fd;
    pfd.events = POLLERR | POLLHUP | POLLNVAL;
    
    int result = poll(&pfd, 1, 0);  // 0 timeout = don't wait
    
    if (result < 0) {
        return false;  // Error
    }
    
    // Check for hangup or error conditions
    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
        return false;  // Pipe disconnected or error
    }
    
    return true;  // Pipe is connected
#endif
}
# class Notes:
#   def __init__(self, notes=None, key=None, bpm=None, mode=0, accidental=None, sampleOffset=0, orderOffset = 0):
#     if type(notes) is str:
#       notes2 = []
#       octave = None
#       for m in noteoro_re.findall(notes):
#         if m[0]:
#           notes2.append(Note(m[0], octave=octave, key=key, bpm=bpm, accidental=accidental, mode=mode))
#         else:
#           octave = int(m[1])
#     elif type(notes) in (Notes, list):
#       for note in notes:
#         if note.playOrder is not None:
#           note.playOrder += orderOffset
#         if note.sampleNumber:
#           note.sampleNumber += sampleOffset
#         note.key = key
#         note.mode = mode
#         note.accidental = accidental
#         if note.sampleNumber:
#           note.sampleNumber += sampleOffset
#         if note.playOrder:
#           note.playOrder += orderOffset
#         notes2.append(note)
#       self.notes = notes2
#     self.__iter__ = self.notes.__iter__
#     self.__next__ = self.notes.__next__
#     self.__getitem__ = self.notes.__getitem__
#     self.__setitem__ = self.notes.__setitem__
#     self.__delitem__ = self.notes.__delitem__
#     self.key = key
#     self.mode = mode
#     self.bpm = bpm
#     self.accidental = accidental


struct rect {int lpindex; int x; int y; int w; int h;};
int lastxpos = 0;
vector<rect> rects;
float httolerance = .5;

int getmaxy(int x, int width)
{
  int maxy=0;
  for(int i = 0; i < rects.size(); i++)
  {
    if (rects[i].x < x+width && rects[i].x+rects[i].w < x)
    {
      if (rects[i].y > maxy)
      {
        maxy=rects[i].y;
      }
    }
  }
  return maxy;
}

/*
          if (editor)
          {
            int width = editor->getWidth();
            int height = editor->getHeight();
            int x = rects[rects.size()-1].x;
            int y = rects[rects.size()-1].y;
            int w = rects[rects.size()-1].w;
            int maxy = 0;

            int newx, newy;
            if (getmaxy(x, width)+height-y>height/httolerance && x+width<screenWidth)
            {
              newx = 0; //debug: untested
              newy = getmaxy(0, width);
            }
            else
            {
              newx = lastxpos;
              newy = getmaxy(lastxpos, width);
              lastxpos += width;
            }
            if (newy+height > screenHeight)
            {
              newx = 0;
              newy = 0;
              rects.clear();
            }
            auto window = make_unique<PluginWindow>(node->getProcessor()->getName(), editor, node->getProcessor(), lpindex);
            window->setTopLeftPosition(newx, newy);
            window->setVisible(true);
            pluginWindows[lpindex] = move(window);
            rects.push_back({newx, newy, width, height}); //todo: remove rect when window closes
          }
*/

      
      rects.erase( //todo: make rects a map instead of this?
        std::remove_if(rects.begin(), rects.end(),
          [lpindex](const rect& r) { 
            return r.lpindex == lpindex; 
          }),
        rects.end()
      );
