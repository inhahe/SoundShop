// juce_gui_server.cpp - GUI server for JUCE plugin hosting with plugin discovery

// Include individual JUCE module headers
#include <juce_core/juce_core.h>
#include <juce_events/juce_events.h>
#include <juce_graphics/juce_graphics.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>

// Make sure we have the plugin host utilities
#if defined __has_include
#if __has_include(<juce_audio_plugin_client/juce_audio_plugin_client.h>)
#include <juce_audio_plugin_client/juce_audio_plugin_client.h>
#endif
#endif

#include <iostream>
#include <thread>
#include <atomic>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <string>
#include <memory>
#include <map>
#include <vector>
#include <atomic>
#include <array>
#include <iostream>
#include <fstream>
#include <string>

#ifdef _WIN32
#include <windows.h>
#include <fcntl.h>
#include <io.h>
#else
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif

using namespace std;
int sampleRate = 44100;
int blockSize = 64;
bool isRecording = true;
bool suppressNotifications = false;
string pipeName = "juceclientserver";

enum cmd {
  load_plugin, load_plugin_by_index, scan_plugins, list_plugins, get_plugin_info, show_plugin_ui, hide_plugin_ui, set_parameter, get_parameter, connect_audio, connect_midi, start_playback,
  stop_playback, cmd_shutdown, remove_plugin, list_bad_paths
};

class CompletePluginHost; 
CompletePluginHost* app = nullptr; 

struct ScheduledParameterChange 
{
  int pluginId;
  int parameterIndex;
  float value;
  uint64_t targetBlockNumber;  // Which audio block to execute on
  bool executed = false;
};

class BlockLevelScheduler 
{
private:
  vector<ScheduledParameterChange> scheduledChanges;
  uint64_t currentBlockNumber = 0;
  int blockSize;  // Set during audio setup

public:
  void setBlockSize(int size) { blockSize = size; }

  // Python calls this to schedule changes
  void scheduleParameterChange(int pluginId, int paramIndex, float value, uint64_t atBlock) 
  {
    ScheduledParameterChange change;
    change.pluginId = pluginId;
    change.parameterIndex = paramIndex;
    change.value = value;
    change.targetBlockNumber = atBlock;

    scheduledChanges.push_back(change);

    // Sort by block number
    sort(scheduledChanges.begin(), scheduledChanges.end(),
      [](const auto& a, const auto& b) { return a.targetBlockNumber < b.targetBlockNumber; });
  }

  // Called at the START of each audio block, before processing
  void processScheduledChanges() ;
  void incrementBlock() { currentBlockNumber++; }
  uint64_t getCurrentBlock() const { return currentBlockNumber; }
};

struct ParameterChangeEvent 
{
  int pluginId;
  int parameterIndex; 
  float value;
  uint64_t blockNumber;
  chrono::steady_clock::time_point timestamp; 
};

class LockFreeParameterQueue 
{
private:
  static constexpr size_t QUEUE_SIZE = 1000000;
  std::array<ParameterChangeEvent, QUEUE_SIZE> queue;
  std::atomic<size_t> writeIndex{0};
  std::atomic<size_t> readIndex{0};

public:
  // Called from audio thread (fast, lock-free)
  bool push(const ParameterChangeEvent& event) 
  {
    size_t currentWrite = writeIndex.load();
    size_t nextWrite = (currentWrite + 1) % QUEUE_SIZE;

    if (nextWrite == readIndex.load()) 
    {
      return false; // Queue full
    }

    queue[currentWrite] = event;
    writeIndex.store(nextWrite);
    return true;
  }

  // Called from main thread
  bool pop(ParameterChangeEvent& event) 
  {
    size_t currentRead = readIndex.load();
    if (currentRead == writeIndex.load()) 
    {
      return false; // Queue empty
    }
    event = queue[currentRead];
    readIndex.store((currentRead + 1) % QUEUE_SIZE);
    return true;
  }
};

LockFreeParameterQueue parameterQueue;

class ParameterChangeListener : public juce::AudioProcessorListener 
{
public:
  void audioProcessorParameterChanged(juce::AudioProcessor* processor, int paramIndex, float value) override;
  void audioProcessorChanged(juce::AudioProcessor* processor, const juce::AudioProcessorListener::ChangeDetails& details) override 
  {
  }
};

ParameterChangeListener paramListener;

class CompletePluginHost : public juce::Timer, public juce::MidiInputCallback
{
public:
  CompletePluginHost()
    : deviceManager(),
    formatManager(),
    knownPluginList(),
    processorGraph(new juce::AudioProcessorGraph()),
    graphPlayer()
  {
    bool running = true;
    // Initialize format manager with plugin formats - be more explicit
    cout << "Initializing plugin formats..." << endl;

    // Add formats individually to make sure they're loaded

    formatManager.addFormat(new juce::VST3PluginFormat());
    cout << "Added VST3 format" << endl;

#ifdef _WIN32
    // Windows named pipe
    cout << "creating pipe" << endl;
    string pipePath = "\\\\.\\pipe\\" + pipeName;
    hPipe = CreateNamedPipeA(
      pipePath.c_str(),
      PIPE_ACCESS_DUPLEX,
      //PIPE_TYPE_MESSAGE
      //PIPE_READMODE_MESSAGE
      PIPE_TYPE_BYTE | PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,
      4096,
      4096,
      0,
      NULL
    );
    if (hPipe == INVALID_HANDLE_VALUE)
    {
      cout << "Failed to create named pipe" << endl;
      throw std::runtime_error("Failed to create named pipe");
    }
#else
    // Unix named pipe (FIFO)
    string pipePath = "/tmp/" + pipeName;
    if (mkfifo(pipeName.c_str(), 0666) == -1 && errno != EEXIST) {
      throw runtime_error("Failed to create FIFO");
    }
    int pipe_fd = open(pipePath.c_str(), O_RDWR);
#endif

#if JUCE_PLUGINHOST_AU && (JUCE_MAC || JUCE_IOS)
    formatManager.addFormat(new juce::AudioUnitPluginFormat());
#endif

    // Also call addDefaultFormats as a backup
//    formatManager.addDefaultFormats();

    cout << "Total formats registered: " << formatManager.getNumFormats() << endl;
    for (int i = 0; i < formatManager.getNumFormats(); ++i)
    {
      cout << "  Format " << i << ": " << formatManager.getFormat(i)->getName() << endl;
    }

    // Initialize audio device
    cout << "initializeAudio()" << endl;  
    initializeAudio();

    // Start timer for periodic updates
    cout << "startTimer(50)" << endl;
    startTimer(50);  // 20Hz update rate
  }

  ~CompletePluginHost()
  {
    stopTimer();
    shutdownAudio();
    processorGraph = nullptr;
#ifdef _WIN32
    CloseHandle(hPipe);
#else
    close(fd);
    unlink(pipePath.c_str());
#endif
  }

  atomic<bool> running = true;

  BlockLevelScheduler scheduler;

  void testFunction() {
    std::cout << "Test function called successfully" << std::endl;
  }

  void timerCallback() override 
  {
    // Process parameter notifications first
    processParameterNotifications();

    // Then handle UI updates
    for (auto it = pluginWindows.begin(); it != pluginWindows.end();) 
    {
      if (!it->second || !it->second->isVisible()) 
      {
        cout << "start pluginWindows.erase(it)" << endl;
        it = pluginWindows.erase(it);
        cout << "end pluginWindows.erase(it)" << endl;
      } 
      else 
      {
        ++it;
      }
    }
  }

  int findPluginId(juce::AudioProcessor* processor) 
  {
    auto it = processorToPluginId.find(processor);
    if (it != processorToPluginId.end()) {
      return it->second;
    }
    return -1;  // Not found
  }

  void initialise(const juce::String& commandLine) {
    std::cout << "initialise: start, app=" << app << std::endl;

    std::cout << "initialise: creating thread, app=" << app << std::endl;
    commandThread = thread([this]() { 
      
      cout << "Thread lambda: started, global app=" << app << std::endl;
      processCommands(); 
      std::cout << "Thread lambda: ended, global app=" << app << std::endl;
      });

    std::cout << "initialise: thread created, app=" << app << std::endl;

    // Check if something here is setting app to null
    std::cout << "initialise: end, app=" << app << std::endl;
  }

  /*void initialise(const juce::String& commandLine)
  {
    // Start command processing thread
    commandThread = thread([this]() { processCommands(); });
  }
  */

  void waitForConnection() 
  {
    std::cout << "Entering waitForConnection()" << std::endl;
#ifdef _WIN32
    // Check if pipe handle is valid
    if (hPipe == INVALID_HANDLE_VALUE) {
      std::cerr << "ERROR: Invalid pipe handle in waitForConnection!" << std::endl;
      return;
    }

    std::cout << "Calling ConnectNamedPipe..." << std::endl;
    BOOL result = ConnectNamedPipe(hPipe, NULL);

    if (!result) {
      DWORD error = GetLastError();
      std::cout << "ConnectNamedPipe returned FALSE, error code: " << error << std::endl;

      if (error == ERROR_PIPE_CONNECTED) {
        std::cout << "Pipe already connected (this is OK)" << std::endl;
      } else if (error == ERROR_INVALID_HANDLE) {
        std::cerr << "ERROR: Invalid handle!" << std::endl;
        return;
      } else if (error == ERROR_PIPE_LISTENING) {
        std::cerr << "ERROR: Pipe already listening!" << std::endl;
        return;
      } else {
        std::cerr << "ERROR: ConnectNamedPipe failed with error " << error << std::endl;
        return;
      }
    } else {
      std::cout << "ConnectNamedPipe succeeded" << std::endl;
      pipeReady = true;
    }
#else
    // Linux - check file descriptor
    if (pipe_fd < 0) {
      std::cerr << "ERROR: Invalid pipe file descriptor!" << std::endl;
      return;
    }
    std::cout << "Linux FIFO ready" << std::endl;
    pipeReady = true;
#endif
  }

  void setPluginParameter(int pluginId, int parameterIndex, float value) {
    auto it = loadedPlugins[pluginId];
    auto node = processorGraph->getNodeForId(it);
    if (node && node->getProcessor()) {
      auto* processor = node->getProcessor();
      if (parameterIndex >= 0 && parameterIndex < processor->getParameters().size()) {
        suppressNotifications = true;  // Prevent recording our own changes
        processor->getParameters()[parameterIndex]->setValue(value);
        suppressNotifications = false;
      }
    }
  }

  void shutdown()
  {
    running = false;
    commandCv.notify_all();

    if (commandThread.joinable())
      commandThread.join();

    // Close all plugin windows
    for (auto& pair : pluginWindows)
    {
      if (pair.second)
        pair.second->closeButtonPressed();
    }
    pluginWindows.clear();
  }

  void handleIncomingMidiMessage(juce::MidiInput* source,
    const juce::MidiMessage& message) override
  {
    // Route MIDI to the processor graph
    if (midiCollector)
      midiCollector->addMessageToQueue(message);
  }

private:
  juce::AudioPluginFormatManager formatManager;
  void initializeAudio()
  {
    // Setup audio device
    auto setup = deviceManager.getAudioDeviceSetup();
    setup.sampleRate = 48000;
    setup.bufferSize = 512;

    juce::String error = deviceManager.initialise(
      2,     // max input channels
      2,     // max output channels
      nullptr,  // no saved state
      true,     // select default device
      {},       // preferred device
      &setup    // preferred setup
    );

    if (error.isNotEmpty())
    {
      cerr << "Audio initialization error: " << error.toStdString() << endl;
    }

    // Setup graph player
    graphPlayer.setProcessor(processorGraph.get());
    deviceManager.addAudioCallback(&graphPlayer);

    // Setup MIDI
    midiCollector = make_unique<juce::MidiMessageCollector>();
    midiCollector->reset(setup.sampleRate);

    // Open MIDI inputs
    auto midiInputs = juce::MidiInput::getAvailableDevices();
    for (const auto& input : midiInputs)
    {
      deviceManager.setMidiInputDeviceEnabled(input.identifier, true);
      deviceManager.addMidiInputDeviceCallback(input.identifier, this);
    }
  }

  void shutdownAudio()
  {
    deviceManager.removeAudioCallback(&graphPlayer);
    deviceManager.closeAudioDevice();
    graphPlayer.setProcessor(nullptr);
  }

  int write4(void* buff, int n)
  {
#ifdef _WIN32
    DWORD bytesWritten;
    if (WriteFile(hPipe, buff, n, &bytesWritten, NULL)) {
      return bytesWritten;
    }
    return -1;  // Error
#else
    return write(pipe_fd, buff, n);
#endif
  }

  // Write string with length prefix
  void write2_string(const string& s)
  {
    int l1 = static_cast<int>(s.length());
    int l2 = 4 + l1;  // 4 bytes for length + string content
    int tosend = l2;

    char* buff = new char[l2];

    // Copy length as first 4 bytes
    memcpy(buff, &l1, 4);
    // Copy string content
    memcpy(buff + 4, s.c_str(), l1);

    // Send all data, handling partial writes
    char* current_pos = buff;
    while (tosend > 0) {
      int byteswritten = write4(current_pos, tosend);
      if (byteswritten > 0) {
        tosend -= byteswritten;
        current_pos += byteswritten;
      }
      else 
      {
#ifdef _WIN32
        throw runtime_error("Error writing to pipe (Windows error: " + to_string(GetLastError()) + ")");
#else
        throw runtime_error("Error writing to pipe (errno: " + to_string(errno) + ")";)
#endif
        break;  // Exit on error
      }
    }
    delete[] buff;
  }

  // Write binary data for non-string types
  template<typename T>
  void write2_binary(T n)
  {
    int tosend = sizeof(T);
    char* current_pos = reinterpret_cast<char*>(&n);

    while (tosend > 0) {
      int byteswritten = write4(current_pos, tosend);
      if (byteswritten > 0) {
        tosend -= byteswritten;
        current_pos += byteswritten;
      }
      else 
      {
#ifdef _WIN32
        throw runtime_error("Error writing to pipe (Windows error: " + to_string(GetLastError()) + ")");
#else
        throw runtime_error("Error writing to pipe (errno: " + to_string(errno) + ")";)
#endif
        break;  // Exit on error
      }
    }
  }

  // Overloaded write2 functions
  inline void write2(const string& s)
  {
    write2_string(s);
  }

  template<typename T>
  inline void write2(T n)
  {
    write2_binary(n);
  }

  template<typename... Args>
  void writeAll(Args&&... args) {
    ((write2(std::forward<Args>(args))), ...);  // C++17 fold expression
  }

#define WRITEALL(...) writeAll(__VA_ARGS__)
  
  // Template function to read any type from pipe
  template<typename T>
  T readFromPipe() 
  {
    T value;
#ifdef _WIN32
    char* buffer = reinterpret_cast<char*>(&value);
    int totalRead = 0;
    while (totalRead < sizeof(T)) {
      DWORD bytesRead;
      if (!ReadFile(hPipe, buffer + totalRead, 
        sizeof(T) - totalRead, &bytesRead, NULL)) {
        throw runtime_error("ReadFile failed: " + to_string(GetLastError()));
      }
      if (bytesRead == 0) {
        throw runtime_error("Pipe closed");
      }
      totalRead += bytesRead;
    }
    return value;
 #else
    if (read(pipe_fd, &value, sizeof(T)) == sizeof(T)) {
      return value;
    }
    throw runtime_error("couldn't read from pipe");
#endif
  }

  // Specialization for strings (reads length-prefixed strings)
  template<>
  string readFromPipe<string>() {
    // Read 4-byte length first
    uint32_t length = readFromPipe<uint32_t>();
    if (length <= 0 || length > 10000) {  // Sanity check
      throw runtime_error("invalid string length");
    }

    char* buffer = new char[length + 1];  // +1 for null terminator
    int totalRead = 0;

#ifdef _WIN32
    while (totalRead < length) {
      DWORD bytesRead;
      if (!ReadFile(hPipe, buffer + totalRead, length - totalRead, &bytesRead, NULL)) {
        delete[] buffer;
        throw runtime_error("ReadFile failed: " + to_string(GetLastError()));
      }
      if (bytesRead == 0) {
        delete[] buffer;
        throw runtime_error("pipe closed");
      }
      totalRead += bytesRead;
    }
#else
    while (totalRead < length) {
      ssize_t bytesRead = read(pipe_fd, buffer + totalRead, length - totalRead);
      if (bytesRead < 0) {
        delete[] buffer;
        throw runtime_error("read failed: " + string(strerror(errno)));
      }
      if (bytesRead == 0) {
        delete[] buffer;
        throw runtime_error("pipe closed");
      }
      totalRead += bytesRead;
    }
#endif

    // Create string with explicit length to handle embedded nulls
    string result(buffer, length);
    delete[] buffer;
    return result;
  }

#define READFROMPIPE(type) readFromPipe<type>()

  // Plugin discovery methods

  void processCommands() {
    std::cout << "Thread: processCommands started" << std::endl;

    try {
      // Wait for pipe to be ready
      std::cout << "Thread: Waiting for pipe..." << std::endl;
      while (!pipeReady && running) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
      }

      std::cout << "Thread: Starting command loop" << std::endl;
      while (running) {
        char command = READFROMPIPE(char);
        cout << "command: " << int(command) << endl;
        processCommand(command);
      }
    } catch (const std::exception& e) {
      std::cout << "Thread: Exception: '" << e.what() << "'" << std::endl;
    } catch (...) {
      std::cout << "Thread: Unknown exception" << std::endl;
    }

    std::cout << "Thread: processCommands ending" << std::endl;
    // Thread ends - this is fine, doesn't affect app pointer
  }

  uint32_t scanPluginDirectory(const juce::File& directory)
  {
    if (!directory.exists()) {
      std::cout << "directory doesn't exist: " << directory.getFullPathName() << std::endl;
      return 0;
    }

    juce::Array<juce::File> pluginFiles;

    // Now search for VST3s
    auto vst3Dirs = directory.findChildFiles(juce::File::findDirectories, true, "*.vst3");
    auto vst3Files = directory.findChildFiles(juce::File::findFiles, true, "*.vst3");
    auto vstFiles = directory.findChildFiles(juce::File::findFiles, true, "*.vst");
    auto dllFiles = directory.findChildFiles(juce::File::findFiles, true, "*.dll");

    pluginFiles.addArray(vst3Dirs);
    pluginFiles.addArray(vst3Files);
    pluginFiles.addArray(vstFiles);
    pluginFiles.addArray(dllFiles); //todo: remember which plugins wouldn't load, so user doesn't have to close a bunch of activation windows

    juce::OwnedArray<juce::PluginDescription> totalDescriptions;
    uint32_t num_found = 0;
    for (const auto& pluginFile : pluginFiles)
    {
      string pathname = pluginFile.getFullPathName().toStdString();
      if (!badPaths.count(pathname))
      {

        for (auto* format : formatManager.getFormats())
        {
          if (format->fileMightContainThisPluginType(pluginFile.getFullPathName()))
          {
            juce::OwnedArray<juce::PluginDescription> descriptions;
            format->findAllTypesForFile(descriptions, pathname);
            for (auto description : descriptions)
            {
              num_found++;
              availablePlugin a;
              a.desc = *description;
              a.path = pathname;
              availablePlugins.push_back(a);
            }
            if (descriptions.size() == 0)
            {
              badPaths.insert(pathname);
            }
          }
        }
      }
    }
    return num_found;
  }

  uint32_t scanPluginDirectories()
  {
    vector<string> directories;
    int n = READFROMPIPE(uint32_t);
    uint32_t num_found = 0;
    for (int x = 0; x < n; x++)
    {
      string d = READFROMPIPE(string);
      directories.push_back(d);
    }
    n = READFROMPIPE(uint32_t);
    for (int x = 0; x < n; x++)
    {
      badPaths.insert(READFROMPIPE(string));
    }
    for (auto directory : directories)
    {
      cout << "scanning directory: " << directory << endl;
      num_found += scanPluginDirectory(juce::File(directory));
    }
    cout << "num_found: " << num_found << endl;
    return num_found;
  }

  void listAvailablePlugins()
  {
    WRITEALL(uint32_t(availablePlugins.size()));
    for (auto plugin : availablePlugins)
    {
      WRITEALL(uint32_t(plugin.desc.isInstrument), uint32_t(plugin.desc.uniqueId), uint32_t(plugin.desc.numInputChannels), uint32_t(plugin.desc.numOutputChannels), plugin.desc.name.toStdString(),
        plugin.desc.descriptiveName.toStdString(), plugin.desc.pluginFormatName.toStdString(), plugin.desc.category.toStdString(), plugin.desc.manufacturerName.toStdString(), plugin.desc.version.toStdString(),
        plugin.desc.fileOrIdentifier.toStdString(), plugin.desc.lastFileModTime.toString(true, true).toStdString(), plugin.path);
    }
  }

  void listBadPaths()
  {
    cout << "badPaths.size()" << badPaths.size() << endl;
    WRITEALL(uint32_t(badPaths.size()));
    for (string badpath : badPaths)
    {
      cout << "writing " << badpath << endl;
      WRITEALL(badpath);
    }
  }
  
  struct loadPluginByIndexR {uint32_t success = true; uint32_t nodeid = -1; string errmsg;};
  loadPluginByIndexR loadPluginByIndex(int index) {  // Return the assigned plugin ID
    loadPluginByIndexR resp;
    if (index >= 0 && index < availablePlugins.size()) 
    {
      const availablePlugin& pluginInfo = availablePlugins[index];

      juce::String errorMessage;
      auto plugin = formatManager.createPluginInstance(
        pluginInfo.desc, sampleRate, blockSize, errorMessage);

      if (plugin != nullptr) 
      {
        if (realtime) plugin->addListener(&paramListener);
        juce::AudioProcessor* processorPtr = plugin.get();
        auto node = processorGraph->addNode(move(plugin));
        if (node != nullptr) {
          int assignedId = nextPluginId++;
          loadedPlugins[assignedId] = node->nodeID;
          processorToPluginId[processorPtr] = assignedId;
          resp.nodeid = assignedId;  // Return the ID Python should use
          resp.success = true;
          return resp;
        }
        else
        {
          resp.success = false;
          resp.errmsg = "Couldn't add node to processor graph";
        }
      }
      else
      {
        resp.errmsg = errorMessage.toStdString();
        resp.success = false;
      }
    }
    else
    {
      resp.success = false;
      resp.errmsg = "Index out of range";
    }
    return resp;
  }

  struct loadPluginR {uint32_t success = false; string errmsg; string name; string uid; };

  loadPluginR loadPlugin(const string& path, const int id)
  {
    loadPluginR resp;

    // Acquire lock to run on message thread
    const juce::MessageManagerLock mml;

    // Check if we got the lock
    if (!mml.lockWasGained()) {
      resp.success = false;
      resp.errmsg = "Could not acquire message manager lock";
      return resp;
    }

    juce::OwnedArray<juce::PluginDescription> descriptions;

    for (auto* format : formatManager.getFormats())
    {
      if (format->fileMightContainThisPluginType(path))
      {
        format->findAllTypesForFile(descriptions, path);
        break;
      }
    }

    if (descriptions.size() > 0)
    {
      const juce::PluginDescription& desc = *descriptions[0];
      juce::String errorMessage;

      auto instance = formatManager.createPluginInstance(
        desc,
        processorGraph->getSampleRate(),
        processorGraph->getBlockSize(),
        errorMessage
      );

      if (instance)
      {
        auto* rawPointer = instance.release();
        auto node = processorGraph->addNode(
          unique_ptr<juce::AudioProcessor>(rawPointer)
        );

        if (node)
        {
          loadedPlugins[id] = node->nodeID;
          processorToPluginId[rawPointer] = id;  // Track reverse mapping

          resp.success = true;
          resp.name = desc.name.toStdString();
          resp.uid = to_string(node->nodeID.uid);
        }
        else
        {
          resp.success = false;
          resp.errmsg = "Failed to add node to graph";
        }
      }
      else
      {
        resp.success = false;
        resp.errmsg = errorMessage.toStdString();
      }
    }
    else
    {
      resp.success = false;
      resp.errmsg = "Plugin not found at path: " + path;
    }

    return resp;
  }
  
  uint32_t showPluginUI(int nodeid)
  {
    auto it = loadedPlugins[nodeid];
    auto node = processorGraph->getNodeForId(it);
    if (node)
    {
      juce::MessageManager::callAsync([this, nodeid, node]() 
      {
        if (node->getProcessor()->hasEditor())
        {
          auto* editor = node->getProcessor()->createEditor();
          if (editor)
          {
            auto window = make_unique<PluginWindow>(
              node->getProcessor()->getName(),
              editor,
              node->getProcessor()
            );

            window->setVisible(true);
            pluginWindows[nodeid] = move(window);
          }
        }
      });
      return true;
    }
    else
    {
      return false;
    }
  }

  uint32_t hidePluginUI(int id)
  {
    auto it = pluginWindows.find(id);
    if (it != pluginWindows.end())
    {
      juce::MessageManager::callAsync([this, id]() {
        pluginWindows.erase(id);
        });
      return true;
    }
    else
    {
      return false;
    }
  }

  struct setParameterR { uint32_t success; string errmsg; };
  setParameterR setParameter(int id, int paramIndex, float value)
  {
    setParameterR resp;
    auto it = loadedPlugins.find(id);
    if (it != loadedPlugins.end())
    {
      auto node = processorGraph->getNodeForId(it->second);
      if (node && node->getProcessor())
      {
        auto* processor = node->getProcessor();
        if (paramIndex >= 0 && paramIndex < processor->getParameters().size())
        {
          processor->getParameters()[paramIndex]->setValue(value);
          resp.success = true;
        }
        else
        {
          resp.success = false;
          resp.errmsg = "Invalid parameter index";
        }
      }
      else
      {
        resp.success = false;
        resp.errmsg = "Plugin node not found";
      }
    }
    else
    {
      resp.success = false;
      resp.errmsg = "Plugin not loaded: " + id;
    }
    return resp;
  }

  struct getParameterR {uint32_t success; float value; string errmsg;};
  getParameterR getParameter(int id, int paramIndex)
  {
    getParameterR resp;

    auto it = loadedPlugins.find(id);
    if (it != loadedPlugins.end())
    {
      auto node = processorGraph->getNodeForId(it->second);
      if (node && node->getProcessor())
      {
        auto* processor = node->getProcessor();
        if (paramIndex >= 0 && paramIndex < processor->getParameters().size())
        {
          float value = processor->getParameters()[paramIndex]->getValue();
          resp.success = true;
          resp.value = value;
        }
        else
        {
          resp.success = false;
          resp.errmsg = "Invalid parameter index";
        }
      }
    }
    else
    {
      resp.success = false;
      resp.errmsg = "Plugin not loaded: " + id;
    }
    return resp;
  }

  uint32_t connectAudio(const int sourceId, int sourceChannel,
    const int destId, int destChannel)
  {

    auto sourceIt = loadedPlugins.find(sourceId);
    auto destIt = loadedPlugins.find(destId);
    if (sourceIt != loadedPlugins.end() && destIt != loadedPlugins.end())
    {
      processorGraph->addConnection({
        {sourceIt->second, sourceChannel},
        {destIt->second, destChannel}
        });
      return true;
    }
    return false;
  }

  uint32_t connectMidi(int sourceId, int destId)
  {
    auto sourceIt = loadedPlugins.find(sourceId);
    auto destIt = loadedPlugins.find(destId);

    if (sourceIt != loadedPlugins.end() && destIt != loadedPlugins.end())
    {
      processorGraph->addConnection({
        {sourceIt->second, juce::AudioProcessorGraph::midiChannelIndex},
        {destIt->second, juce::AudioProcessorGraph::midiChannelIndex}
        });
      return true;
    }

    return false;
  }

  void startPlayback()
  {
  }

  void stopPlayback()
  {
  }

  void removePlugin(int pluginId) {
    auto it = loadedPlugins.find(pluginId);
    if (it != loadedPlugins.end()) {
      auto node = processorGraph->getNodeForId(it->second);
      if (node) {
        processorToPluginId.erase(node->getProcessor());
      }
      processorGraph->removeNode(it->second);
      loadedPlugins.erase(it);
    }
  }

  void clearAllPlugins() {
    processorToPluginId.clear();
    loadedPlugins.clear();
    pluginWindows.clear();
    processorGraph->clear();
  }

  void processCommand(char command)
  {
    auto commandtype = (cmd)command;
    switch (commandtype)
    {
      case load_plugin:
      {
        auto response = loadPlugin(READFROMPIPE(string), READFROMPIPE(uint32_t));
        WRITEALL(response.success);
        if(response.success) WRITEALL(response.name, response.uid);
        else WRITEALL(response.errmsg);
        break;
      }
      case remove_plugin:
      {
        removePlugin(READFROMPIPE(uint32_t));
        break;
      }
      case load_plugin_by_index:
      {
        cout << "reading index " << endl;
        int index = READFROMPIPE(uint32_t);
        cout << "loading plugin " << index << endl;
        auto response = loadPluginByIndex(index);
        cout << "loaded plugin " << index << endl;
        WRITEALL(response.success, response.nodeid, response.errmsg);
        break;
      }
      case scan_plugins:
      {
        WRITEALL(scanPluginDirectories());
        break;
      }
      case list_plugins:
      {
        listAvailablePlugins();
        break;
      }
      case show_plugin_ui:
      {
        auto response = showPluginUI(READFROMPIPE(uint32_t));
        WRITEALL(response.success, response.errmsg);
        break;
      }
      case hide_plugin_ui:
      {
        WRITEALL(hidePluginUI(READFROMPIPE(uint32_t)));
        break;
      }
      case set_parameter: //probably won't be used.
      {
        auto response = setParameter(READFROMPIPE(uint32_t), READFROMPIPE(uint32_t), READFROMPIPE(float));
        WRITEALL(response.success, response.errmsg);
        break;
        break;
      }
      case get_parameter: //probably won't be used.
      {
        auto response = getParameter(READFROMPIPE(uint32_t), READFROMPIPE(uint32_t));
        WRITEALL(response.success, response.value, response.errmsg);
        break;
      }
      case connect_audio:
      {
        WRITEALL(connectAudio(READFROMPIPE(uint32_t), READFROMPIPE(uint32_t), READFROMPIPE(uint32_t), READFROMPIPE(uint32_t)));
        break;
      }
      case connect_midi:
      {
        WRITEALL(connectMidi(READFROMPIPE(uint32_t), READFROMPIPE(uint32_t)));
        break;
      }
      case start_playback:
      {
        startPlayback();
        break;
      }
      case stop_playback:
      {
        stopPlayback();
        break;
      }
      case cmd_shutdown:
      {
        clearAllPlugins();
        running = false;
        break;
      }
      case list_bad_paths:
      {
        cout << "got command: list_bad_paths" << endl;
        listBadPaths();
        break;
      }
      default:
      {
        cout << "command not recognized: " << commandtype << endl;
      }
    }
  }

  // Plugin window class
  class PluginWindow : public juce::DocumentWindow
  {
  public:
    PluginWindow(const juce::String& name,
      juce::AudioProcessorEditor* editor,
      juce::AudioProcessor* processor)
      : DocumentWindow(name, 
        juce::Desktop::getInstance().getDefaultLookAndFeel()
        .findColour(ResizableWindow::backgroundColourId),
        DocumentWindow::allButtons),
      processor(processor)
    {
      setUsingNativeTitleBar(true);
      setContentOwned(editor, true);
      setResizable(editor->isResizable(), false);
      centreWithSize(getWidth(), getHeight());
    }

    void closeButtonPressed() override
    {
      setVisible(false);
    }

  private:
    juce::AudioProcessor* processor;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PluginWindow)
  };

private:
  // Core components
#ifdef _WIN32
  HANDLE hPipe;
#else
  int pipe_fd;
#endif
  bool pipeReady = false;
  long int currentBlock = 0;
  bool realtime = false;
  bool threadStarted = false;
  juce::AudioDeviceManager deviceManager;
  juce::KnownPluginList knownPluginList;
  unique_ptr<juce::AudioProcessorGraph> processorGraph;
  juce::AudioProcessorPlayer graphPlayer;
  unique_ptr<juce::MidiMessageCollector> midiCollector;

  // Plugin management
  map<int, juce::AudioProcessorGraph::NodeID> loadedPlugins;  // int ID -> NodeID
  map<juce::AudioProcessor*, int> processorToPluginId;
  map<int, unique_ptr<PluginWindow>> pluginWindows;       // int ID -> Window
  int nextPluginId = 0;  // Auto-increment ID counter

  struct availablePlugin
  {
    string path;
    juce::PluginDescription desc;
  };
  vector<availablePlugin> availablePlugins;
  set<string> badPaths;

  // Communication
  thread commandThread;
  //queue<Command> commandQueue;
  mutex commandMutex;
  condition_variable commandCv;

  void processParameterNotifications()
  {
    ParameterChangeEvent event;
    while (parameterQueue.pop(event)) 
    {
      // Send to Python via pipe (safe here - not in audio thread)
      WRITEALL("PARAM_CHANGED", event.pluginId, event.parameterIndex, event.value);
    }
  }

  JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CompletePluginHost)
};

void audioProcessorParameterChanged(juce::AudioProcessor* processor, int paramIndex, float value) {
  if (!suppressNotifications) {
    ParameterChangeEvent event{app->findPluginId(processor), paramIndex, value, app->scheduler.getCurrentBlock()};
    parameterQueue.push(event);  // Lock-free, real-time safe
  }
}

void BlockLevelScheduler::processScheduledChanges() 
{
  for (auto& change : scheduledChanges) 
  {
    if (!change.executed && currentBlockNumber >= change.targetBlockNumber) 
    {
      // Execute the parameter change RIGHT BEFORE this block processes
      app->setPluginParameter(change.pluginId, change.parameterIndex, change.value);
      change.executed = true;

      cout << "Executed parameter change at block " << currentBlockNumber
        << ": plugin " << change.pluginId
        << ", param " << change.parameterIndex
        << " = " << change.value << endl;
    }
  }
}

void ParameterChangeListener::audioProcessorParameterChanged(juce::AudioProcessor* processor, int paramIndex, float value)  
{
  ParameterChangeEvent changeevent;
  if (!suppressNotifications) 
  {
    int pluginId = app->findPluginId(processor);
    if (pluginId != -1) 
    {
      changeevent.blockNumber = app->scheduler.getCurrentBlock();
      changeevent.parameterIndex = paramIndex;
      changeevent.value = value;
      changeevent.pluginId = pluginId;
      changeevent.timestamp = chrono::steady_clock::now();
      parameterQueue.push(changeevent);
    }
  }
}

// Entry point
#ifdef _WIN32
// Use extern "C" to ensure proper linkage

bool isAllWhitespace(const std::string& str) 
{
  return str.empty() || str.find_first_not_of(" \t\n\r\f\v") == std::string::npos;
}

extern "C" int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
  try {
    if (!isAllWhitespace(lpCmdLine))
    {
      pipeName = lpCmdLine;
    }    
    // Allocate a console window for this GUI application
    AllocConsole();

    // Redirect stdout, stdin, stderr to console
    FILE* pCout;
    freopen_s(&pCout, "CONOUT$", "w", stdout);
    freopen_s(&pCout, "CONOUT$", "w", stderr);
    freopen_s(&pCout, "CONIN$", "r", stdin);

    std::cout.clear();
    std::cerr.clear();
    std::cin.clear();
 
  // Suppress unused parameter warnings
    (void)hInstance;
    (void)hPrevInstance;
    (void)nCmdShow;
    
#ifdef _WIN64
    cout << "compiled as 64-bit, so will only detect 64-bit plugins" << std::endl; //todo: notify of plugins found that are the wrong number of bits
#else
    cout << "compiled as 32-bit, so will only detect 32-bit plugins" << std::endl;
#endif
    cout << "formats supported:" << endl;
    juce::AudioFormatManager formatManager;
    for (auto* format : formatManager) 
    {  
      std::cout << format->getFormatName().toStdString() << std::endl;
    }
    cout << "using pipe: " << pipeName << endl;
    juce::initialiseJuce_GUI();
    app = new CompletePluginHost();
    app->testFunction();
    app->waitForConnection();
    app->initialise(juce::String(lpCmdLine));
    juce::MessageManager::getInstance()->runDispatchLoop();
    app->shutdown();
    juce::shutdownJuce_GUI();
    cout << endl << "press enter to close..." << endl;
    cin.get();
  } 
  catch (const exception& e) 
  {
    cout << "exception: " << e.what() << std::endl;
    cout << endl << "press enter to close..." << endl;
    cin.get();
  }
  return 0;
}
#else
// For Mac/Linux, use standard main
int main(int argc, char* argv[])
{
    juce::initialiseJuce_GUI();
    
    juce::String commandLine;
    if (argc > 1)
    {
        for (int i = 1; i < argc; ++i)
        {
            if (i > 1) commandLine << " ";
            commandLine << argv[i];
        }
    }
    
    CompletePluginHost app;
    app->initialise(commandLine);
    
    juce::MessageManager::getInstance()->runDispatchLoop();
    
    app->shutdown();
    juce::shutdownJuce_GUI();
    
    return 0;
}
#endif